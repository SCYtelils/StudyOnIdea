#进阶4
/*
概念：类似于java的方法，将一组逻辑语句封装在方法体中，对外暴露方法名
好处：1.隐藏了实现细节 2.提高代码的重用性
调用：select 函数名(实参列表) 【from 表】
特点：
			1）叫什么（函数名）
			2）干什么（函数功能）
分类：
			1.单行函数
			如concat,length,ifnull等
			2.分组函数
			功能：做统计使用，又称为统计函数、聚合函数、组函数
*/

#一、字符函数

#1.length 获取参数值得字节个数
SELECT LENGTH('john');
SELECT LENGTH('张三丰hahaha');

SHOW VARIABLES LIKE '%char%';

#2.concat 拼接字符串
SELECT CONCAT(last_name,'_',first_name) as 姓名 FROM employees;

#3.upper、lower 大小写转换
SELECT UPPER('john');
SELECT LOWER('joHn');
#示例：将姓变大写，名变小写，然后拼接
SELECT CONCAT(UPPER(last_name),LOWER(first_name)) as 姓名 FROM employees;

#4.substr或substring 分割字符串
注意：索引从1开始
#截取从指定索引处后面得字符
SELECT SUBSTR('李莫愁爱上了陆展元',7) as out_put;

#截取从指定索引处指定字符长度的字符
SELECT SUBSTR('李莫愁爱上了陆展元',1,3) as out_put;

#案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来
SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),'_',LOWER(SUBSTR(last_name,2))) as out_put
FROM employees;

#5.instr 返回子串第一次出现的索引，如果找不到返回0
SELECT INSTR('杨不悔爱上了殷六侠','殷六侠') as out_put;

#6.trim 去除前后指定字符（如果只有一个参数默认去除前后的空格）
SELECT TRIM('      张翠山         ') as out_put;
SELECT TRIM('a' FROM'aaaaaaaaaaaa张翠山aaaaaaaaaaaaaaaaa') as out_put;

#7.lpad 用指定的字符实现左填充指定长度
SELECT LPAD('殷素素',12,'*') as out_put;

#8.rpad 用指定的字符实现右填充指定长度
SELECT RPAD('殷素素',12,'*') as out_put;

#9.replace 替换
SELECT REPLACE('张无忌爱上了周芷若','周芷若','赵敏') as out_put;

#二、数学函数

#round 四舍五入（第二个参数是取小数点后几位）
SELECT ROUND(1.55);
SELECT ROUND(1.567,2);

#ceil 向上取整，返回>=该参数的最小整数
SELECT CEIL(1.02);

#floor 向下取整，返回<=该参数的最大整数
SELECT FLOOR(9.99);

#truncate 截断
SELECT TRUNCATE(1.699,1);

#mod 取余
/*
无论是Java还是mysql，取余操作的公式都如下：
mod(a,b) :  a-a/b*b
*/
SELECT MOD(10,3);
SELECT 10%3;

#三、日期函数

#now 返回当前系统日期+时间
SELECT NOW();

#curdate 返回当前系统日期，不包含时间
SELECT CURDATE();

#curtime 返回当前时间，不包含日期
SELECT CURTIME();

#可以获取指定的部分，年、月、日、小时、分钟、秒
SELECT YEAR(NOW()) as 年;
SELECT YEAR('1998-2-1') as 年;

SELECT YEAR(hiredate) 年 FROM employees;

SELECT MONTH(NOW()) 月;
SELECT MONTHNAME(NOW()) 月;

#str_to_date 将字符通过指定的格式转换成日期
SELECT STR_TO_DATE('1998-3-2','%Y-%c-%d') as out_put;

#查询入职日期为1992-4-2的员工信息
SELECT * FROM employees WHERE hiredate = '1992-4-2';
SELECT * FROM employees WHERE hiredate= STR_TO_DATE('4-2 1992','%c-%d %Y');

#date_format 将日期转换成字符（%y显示小年份，%Y显示大年份）
SELECT DATE_FORMAT(NOW(),'%Y年%c月%d日') AS out_put;

#查询有奖金的员工名和入职日期（xx月/xx日 xx年）
SELECT last_name,DATE_FORMAT(hirdate,'%m月/%d日 %Y年') 入职日期
FROM employees
WHERE commission_pct IS NOT NULL;

#四、其他函数

SELECT VERSION();
SELECT DATABASE();
SELECT USER();

#五、流程控制函数
#1.if函数：if else 的效果
SELECT IF(10<5,'大','小');

SELECT last_name,commission_pct,IF(commission_pct IS NULL,'没奖金，呵呵','有奖金，嘻嘻')
FROM employees;

#case函数的使用一：switch case的效果
/*
case 要判断的字段或表达式
when 常量1 then 要显示的值1或语句1;
when 常量2 then 要显示的值2或语句2;
...
else 要显示的值n或语句n;
end
*/

/*#案例：查询员工的工资，要求

部门号=30，显示的工资为1.1倍
部门号=40，显示的工资为1.2倍
部门号=50，显示的工资为1.3倍
其他部门，显示的工资为原工资
*/

SELECT salary 原始工资,department_id,
CASE department_id
WHEN 30 THEN salary*1.1
WHEN 40 THEN salary*1.2
WHEN 50 THEN salary*1.3
ELSE salary
END AS 新工资
FROM employees;

#case函数的使用二：类似于多重if
/*
case
when 条件1 then 要显示的值1或语句1;
when 条件2 then 要显示的值2或语句2;
...
else 要显示的值n或语句n;
end
*/

#案例：查询员工的工资的情况
/*
如果工资>20000,显示A级别
如果工资>15000,显示B级别
如果工资>10000,显示C级别
否则，显示D级别
*/
SELECT salary,
CASE
WHEN salary>20000 THEN 'A'
WHEN salary>15000 THEN 'B'
WHEN salary>10000 THEN 'C'
ELSE 'D'
END as 工资等级
FROM employees;

#二、分组函数
/*
功能：用作统计使用，又称为聚合函数或统计函数或组函数

分类：
sum求和，avg平均值，max最大值，min最小值，count计算个数

特点：
1.sum,avg一般用于处理数值型
	max,min,count可以处理任何类型

2.以上分组函数都忽略null值

3.可以和distinct搭配实现去重的运算

4.count函数的单独介绍
一般使用count(*)用作统计行数

5.和分组函数一同查询的字段要求是group by后的字段
*/

#1.简单的使用
SELECT SUM(salary) FROM employees;
SELECT AVG(salary) FROM employees;
SELECT MIN(salary) FROM employees;
SELECT MAX(salary) FROM employees;
SELECT COUNT(salary) FROM employees;

#2.和distinct搭配
SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;
SELECT COUNT(DISTINCT salary) FROM employees;

#3.count函数的详细介绍
SELECT COUNT(salary) FROM employees;  #放字段名查总个数
SELECT COUNT(*) FROM employees;  #放*查总个数
SELECT COUNT(1) FROM employees;  #放一个常量查总个数

效率：
MYISAM存储引擎下，COUNT(*)的效率高
INNODB存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些

#4.和分组函数一同查询的字段有限制
SELECT AVG(salary),employees_id FROM employees;











